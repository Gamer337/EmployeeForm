import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { factory } from './js-sha256';
const sha256 = factory();
import fsha256 from 'fast-sha256';
/**
 * Abstraction for crypto algorithms
 */
export class HashHandler {
}
function decodeUTF8(s) {
    if (typeof s !== 'string')
        throw new TypeError('expected string');
    var i, d = s, b = new Uint8Array(d.length);
    for (i = 0; i < d.length; i++)
        b[i] = d.charCodeAt(i);
    return b;
}
function encodeUTF8(arr) {
    var i, s = [];
    for (i = 0; i < arr.length; i++)
        s.push(String.fromCharCode(arr[i]));
    return s.join('');
}
export class DefaultHashHandler {
    calcHash(valueToHash, algorithm) {
        return __awaiter(this, void 0, void 0, function* () {
            // const encoder = new TextEncoder();
            // const hashArray = await window.crypto.subtle.digest(algorithm, data);
            // const data = encoder.encode(valueToHash);
            // const fhash = fsha256(valueToHash);
            const candHash = encodeUTF8(fsha256(decodeUTF8(valueToHash)));
            // const hashArray = (sha256 as any).array(valueToHash);
            // // const hashString = this.toHashString(hashArray);
            // const hashString = this.toHashString2(hashArray);
            // console.debug('hash orig - cand', candHash, hashString);
            // alert(1);
            return candHash;
        });
    }
    toHashString2(byteArray) {
        let result = '';
        for (let e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
    toHashString(buffer) {
        const byteArray = new Uint8Array(buffer);
        let result = '';
        for (let e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
}
DefaultHashHandler.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbGliL3NyYy90b2tlbi12YWxpZGF0aW9uL2hhc2gtaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3RDLE1BQU0sTUFBTSxHQUFHLE9BQU8sRUFBRSxDQUFDO0FBRXpCLE9BQU8sT0FBTyxNQUFNLGFBQWEsQ0FBQztBQUVsQzs7R0FFRztBQUNILE1BQU0sT0FBZ0IsV0FBVztDQUVoQztBQUVELFNBQVMsVUFBVSxDQUFDLENBQUM7SUFDbkIsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRO1FBQUUsTUFBTSxJQUFJLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2xFLElBQUksQ0FBQyxFQUNILENBQUMsR0FBRyxDQUFDLEVBQ0wsQ0FBQyxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO1FBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEQsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBRUQsU0FBUyxVQUFVLENBQUMsR0FBRztJQUNyQixJQUFJLENBQUMsRUFDSCxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ1QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtRQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNwQixDQUFDO0FBR0QsTUFBTSxPQUFPLGtCQUFrQjtJQUN2QixRQUFRLENBQUMsV0FBbUIsRUFBRSxTQUFpQjs7WUFDbkQscUNBQXFDO1lBQ3JDLHdFQUF3RTtZQUN4RSw0Q0FBNEM7WUFFNUMsc0NBQXNDO1lBRXRDLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUU5RCx3REFBd0Q7WUFDeEQsc0RBQXNEO1lBQ3RELG9EQUFvRDtZQUVwRCwyREFBMkQ7WUFDM0QsWUFBWTtZQUVaLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUM7S0FBQTtJQUVELGFBQWEsQ0FBQyxTQUFtQjtRQUMvQixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDaEIsS0FBSyxJQUFJLENBQUMsSUFBSSxTQUFTLEVBQUU7WUFDdkIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEM7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsWUFBWSxDQUFDLE1BQW1CO1FBQzlCLE1BQU0sU0FBUyxHQUFHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNoQixLQUFLLElBQUksQ0FBQyxJQUFJLFNBQVMsRUFBRTtZQUN2QixNQUFNLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7OztZQXBDRixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBmYWN0b3J5IH0gZnJvbSAnLi9qcy1zaGEyNTYnO1xuY29uc3Qgc2hhMjU2ID0gZmFjdG9yeSgpO1xuXG5pbXBvcnQgZnNoYTI1NiBmcm9tICdmYXN0LXNoYTI1Nic7XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIGNyeXB0byBhbGdvcml0aG1zXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBIYXNoSGFuZGxlciB7XG4gIGFic3RyYWN0IGNhbGNIYXNoKHZhbHVlVG9IYXNoOiBzdHJpbmcsIGFsZ29yaXRobTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG5mdW5jdGlvbiBkZWNvZGVVVEY4KHMpIHtcbiAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgc3RyaW5nJyk7XG4gIHZhciBpLFxuICAgIGQgPSBzLFxuICAgIGIgPSBuZXcgVWludDhBcnJheShkLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSBiW2ldID0gZC5jaGFyQ29kZUF0KGkpO1xuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVVRGOChhcnIpIHtcbiAgdmFyIGksXG4gICAgcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhcnJbaV0pKTtcbiAgcmV0dXJuIHMuam9pbignJyk7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEZWZhdWx0SGFzaEhhbmRsZXIgaW1wbGVtZW50cyBIYXNoSGFuZGxlciB7XG4gIGFzeW5jIGNhbGNIYXNoKHZhbHVlVG9IYXNoOiBzdHJpbmcsIGFsZ29yaXRobTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgLy8gY29uc3QgaGFzaEFycmF5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgLy8gY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlVG9IYXNoKTtcblxuICAgIC8vIGNvbnN0IGZoYXNoID0gZnNoYTI1Nih2YWx1ZVRvSGFzaCk7XG5cbiAgICBjb25zdCBjYW5kSGFzaCA9IGVuY29kZVVURjgoZnNoYTI1NihkZWNvZGVVVEY4KHZhbHVlVG9IYXNoKSkpO1xuXG4gICAgLy8gY29uc3QgaGFzaEFycmF5ID0gKHNoYTI1NiBhcyBhbnkpLmFycmF5KHZhbHVlVG9IYXNoKTtcbiAgICAvLyAvLyBjb25zdCBoYXNoU3RyaW5nID0gdGhpcy50b0hhc2hTdHJpbmcoaGFzaEFycmF5KTtcbiAgICAvLyBjb25zdCBoYXNoU3RyaW5nID0gdGhpcy50b0hhc2hTdHJpbmcyKGhhc2hBcnJheSk7XG5cbiAgICAvLyBjb25zb2xlLmRlYnVnKCdoYXNoIG9yaWcgLSBjYW5kJywgY2FuZEhhc2gsIGhhc2hTdHJpbmcpO1xuICAgIC8vIGFsZXJ0KDEpO1xuXG4gICAgcmV0dXJuIGNhbmRIYXNoO1xuICB9XG5cbiAgdG9IYXNoU3RyaW5nMihieXRlQXJyYXk6IG51bWJlcltdKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGUgb2YgYnl0ZUFycmF5KSB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRvSGFzaFN0cmluZyhidWZmZXI6IEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgZm9yIChsZXQgZSBvZiBieXRlQXJyYXkpIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaGV4U3RyaW5nKGJ1ZmZlcikge1xuICAvLyAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgLy8gICAgIGNvbnN0IGhleENvZGVzID0gWy4uLmJ5dGVBcnJheV0ubWFwKHZhbHVlID0+IHtcbiAgLy8gICAgICAgY29uc3QgaGV4Q29kZSA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgLy8gICAgICAgY29uc3QgcGFkZGVkSGV4Q29kZSA9IGhleENvZGUucGFkU3RhcnQoMiwgJzAnKTtcbiAgLy8gICAgICAgcmV0dXJuIHBhZGRlZEhleENvZGU7XG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgcmV0dXJuIGhleENvZGVzLmpvaW4oJycpO1xuICAvLyAgIH1cblxuICAvLyB0b0hhc2hTdHJpbmcoaGV4U3RyaW5nOiBzdHJpbmcpIHtcbiAgLy8gICBsZXQgcmVzdWx0ID0gJyc7XG4gIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXhTdHJpbmcubGVuZ3RoOyBpICs9IDIpIHtcbiAgLy8gICAgIGxldCBoZXhEaWdpdCA9IGhleFN0cmluZy5jaGFyQXQoaSkgKyBoZXhTdHJpbmcuY2hhckF0KGkgKyAxKTtcbiAgLy8gICAgIGxldCBudW0gPSBwYXJzZUludChoZXhEaWdpdCwgMTYpO1xuICAvLyAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobnVtKTtcbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgLy8gfVxufVxuIl19